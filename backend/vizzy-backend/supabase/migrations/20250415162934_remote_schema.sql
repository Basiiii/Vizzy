create schema if not exists "postgis";

create extension if not exists "postgis" with schema "postgis" version '3.3.7';

create sequence "postgis"."locations_id_seq";

create table "postgis"."locations" (
    "id" integer not null default nextval('postgis.locations_id_seq'::regclass),
    "full_address" text not null,
    "created_at" timestamp without time zone not null default now(),
    "location" postgis.geography(Point,4326) not null,
    "lat" double precision not null,
    "lon" double precision not null
);


alter table "postgis"."locations" enable row level security;

alter sequence "postgis"."locations_id_seq" owned by "postgis"."locations"."id";

CREATE UNIQUE INDEX locations_location_key ON postgis.locations USING btree (location);

CREATE UNIQUE INDEX locations_pkey ON postgis.locations USING btree (id);

alter table "postgis"."locations" add constraint "locations_pkey" PRIMARY KEY using index "locations_pkey";

alter table "postgis"."locations" add constraint "locations_location_key" UNIQUE using index "locations_location_key";

create type "postgis"."geometry_dump" as ("path" integer[], "geom" postgis.geometry);

create type "postgis"."valid_detail" as ("valid" boolean, "reason" character varying, "location" postgis.geometry);

grant select on table "postgis"."locations" to "service_role";

create policy "Enable read access for all users"
on "postgis"."locations"
as permissive
for select
to service_role
using (true);



create sequence "public"."contacts_id_seq";

create sequence "public"."listing_statuses_id_seq";

create sequence "public"."product_categories_id_seq";

create sequence "public"."product_listings_id_seq";

create sequence "public"."proposal_statuses_id_seq";

create sequence "public"."proposal_types_id_seq";

create sequence "public"."proposals_id_seq";

create sequence "public"."rental_availability_id_seq";

create sequence "public"."transaction_statuses_id_seq";

create sequence "public"."transactions_id_seq";

create table "public"."blocked_users" (
    "blocker_id" uuid not null,
    "blocked_id" uuid not null
);


alter table "public"."blocked_users" enable row level security;

create table "public"."contacts" (
    "id" integer not null default nextval('contacts_id_seq'::regclass),
    "name" text not null,
    "description" text,
    "phone_number" text not null,
    "user_id" uuid not null
);


alter table "public"."contacts" enable row level security;

create table "public"."favorites" (
    "user_id" uuid not null,
    "listing_id" integer not null
);


alter table "public"."favorites" enable row level security;

create table "public"."giveaway_listings" (
    "id" integer not null default nextval('product_listings_id_seq'::regclass),
    "title" text,
    "description" text,
    "date_created" timestamp without time zone default now(),
    "owner_id" uuid,
    "category_id" integer,
    "listing_status" integer,
    "recipient_requirements" character varying
) inherits ("public"."product_listings");


alter table "public"."giveaway_listings" enable row level security;

create table "public"."giveaway_proposals" (
    "id" integer not null default nextval('proposals_id_seq'::regclass),
    "title" character varying(255),
    "description" character varying(255),
    "sender_id" uuid,
    "receiver_id" uuid,
    "listing_id" integer,
    "proposal_type_id" integer,
    "proposal_status_id" integer default 1,
    "created_at" timestamp without time zone not null default now(),
    "message" character varying
) inherits ("public"."proposals");


alter table "public"."giveaway_proposals" enable row level security;

create table "public"."listing_statuses" (
    "id" integer not null default nextval('listing_statuses_id_seq'::regclass),
    "description" character varying(255)
);


alter table "public"."listing_statuses" enable row level security;

create table "public"."listing_types" (
    "id" integer not null default nextval('proposal_types_id_seq'::regclass),
    "description" character varying(255)
);


alter table "public"."listing_types" enable row level security;

create table "public"."password_reset_tokens" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "token" text not null,
    "created_at" timestamp with time zone not null default now(),
    "expires_at" timestamp with time zone not null,
    "used" boolean not null default false
);


alter table "public"."password_reset_tokens" enable row level security;

create table "public"."product_categories" (
    "id" integer not null default nextval('product_categories_id_seq'::regclass),
    "category" character varying(255) not null
);


alter table "public"."product_categories" enable row level security;

create table "public"."product_conditions" (
    "id" bigint generated by default as identity not null,
    "condition" text not null default ''::text
);


alter table "public"."product_conditions" enable row level security;

create table "public"."product_images" (
    "product_listing_id" integer not null,
    "image_path" character varying(255) not null
);


alter table "public"."product_images" enable row level security;

create table "public"."product_listings" (
    "id" integer not null default nextval('product_listings_id_seq'::regclass),
    "title" text,
    "description" text,
    "date_created" timestamp without time zone default now(),
    "owner_id" uuid,
    "category_id" integer,
    "listing_status" integer
);


alter table "public"."product_listings" enable row level security;

create table "public"."profiles" (
    "id" uuid not null default auth.uid(),
    "username" text not null,
    "name" text not null,
    "location_id" integer,
    "is_deleted" boolean default false,
    "deleted_at" timestamp with time zone,
    "email" text not null
);


alter table "public"."profiles" enable row level security;

create table "public"."proposal_statuses" (
    "id" integer not null default nextval('proposal_statuses_id_seq'::regclass),
    "description" character varying(255)
);


alter table "public"."proposal_statuses" enable row level security;

create table "public"."proposals" (
    "id" integer not null default nextval('proposals_id_seq'::regclass),
    "title" character varying(255),
    "description" character varying(255),
    "sender_id" uuid,
    "receiver_id" uuid,
    "listing_id" integer,
    "proposal_type_id" integer,
    "proposal_status_id" integer default 1,
    "created_at" timestamp without time zone not null default now()
);


alter table "public"."proposals" enable row level security;

create table "public"."rental_availability" (
    "id" integer not null default nextval('rental_availability_id_seq'::regclass),
    "rental_listing_id" integer,
    "start_date" timestamp without time zone,
    "end_date" timestamp without time zone
);


alter table "public"."rental_availability" enable row level security;

create table "public"."rental_listings" (
    "id" integer not null default nextval('product_listings_id_seq'::regclass),
    "title" text,
    "description" text,
    "date_created" timestamp without time zone default now(),
    "owner_id" uuid,
    "category_id" integer,
    "listing_status" integer,
    "deposit_required" boolean,
    "cost_per_day" numeric,
    "auto_close_date" timestamp without time zone,
    "rental_duration_limit" integer,
    "late_fee" numeric
) inherits ("public"."product_listings");


alter table "public"."rental_listings" enable row level security;

create table "public"."rental_proposals" (
    "id" integer not null default nextval('proposals_id_seq'::regclass),
    "title" character varying(255),
    "description" character varying(255),
    "sender_id" uuid,
    "receiver_id" uuid,
    "listing_id" integer,
    "proposal_type_id" integer,
    "proposal_status_id" integer default 1,
    "created_at" timestamp without time zone not null default now(),
    "offered_rent_per_day" numeric,
    "start_date" timestamp without time zone,
    "end_date" timestamp without time zone
) inherits ("public"."proposals");


alter table "public"."rental_proposals" enable row level security;

create table "public"."sale_listings" (
    "id" integer not null default nextval('product_listings_id_seq'::regclass),
    "title" text,
    "description" text,
    "date_created" timestamp without time zone default now(),
    "owner_id" uuid,
    "category_id" integer,
    "listing_status" integer,
    "price" numeric,
    "product_condition" integer,
    "is_negotiable" boolean
) inherits ("public"."product_listings");


alter table "public"."sale_listings" enable row level security;

create table "public"."sale_proposals" (
    "id" integer not null default nextval('proposals_id_seq'::regclass),
    "title" character varying(255),
    "description" character varying(255),
    "sender_id" uuid,
    "receiver_id" uuid,
    "listing_id" integer,
    "proposal_type_id" integer,
    "proposal_status_id" integer default 1,
    "created_at" timestamp without time zone not null default now(),
    "offered_price" numeric
) inherits ("public"."proposals");


alter table "public"."sale_proposals" enable row level security;

create table "public"."swap_listings" (
    "id" integer not null default nextval('product_listings_id_seq'::regclass),
    "title" text,
    "description" text,
    "date_created" timestamp without time zone default now(),
    "owner_id" uuid,
    "category_id" integer,
    "listing_status" integer,
    "desired_item" character varying
) inherits ("public"."product_listings");


alter table "public"."swap_listings" enable row level security;

create table "public"."swap_proposals" (
    "id" integer not null default nextval('proposals_id_seq'::regclass),
    "title" character varying(255),
    "description" character varying(255),
    "sender_id" uuid,
    "receiver_id" uuid,
    "listing_id" integer,
    "proposal_type_id" integer,
    "proposal_status_id" integer default 1,
    "created_at" timestamp without time zone not null default now(),
    "swap_with" character varying
) inherits ("public"."proposals");


alter table "public"."swap_proposals" enable row level security;

create table "public"."transaction_statuses" (
    "id" integer not null default nextval('transaction_statuses_id_seq'::regclass),
    "description" character varying(255)
);


alter table "public"."transaction_statuses" enable row level security;

create table "public"."transactions" (
    "id" integer not null default nextval('transactions_id_seq'::regclass),
    "date_created" timestamp without time zone default now(),
    "transaction_status" integer,
    "listing_id" integer,
    "proposal_id" integer,
    "seller_id" uuid,
    "buyer_id" uuid
);


alter table "public"."transactions" enable row level security;

alter sequence "public"."contacts_id_seq" owned by "public"."contacts"."id";

alter sequence "public"."listing_statuses_id_seq" owned by "public"."listing_statuses"."id";

alter sequence "public"."product_categories_id_seq" owned by "public"."product_categories"."id";

alter sequence "public"."product_listings_id_seq" owned by "public"."product_listings"."id";

alter sequence "public"."proposal_statuses_id_seq" owned by "public"."proposal_statuses"."id";

alter sequence "public"."proposal_types_id_seq" owned by "public"."listing_types"."id";

alter sequence "public"."proposals_id_seq" owned by "public"."proposals"."id";

alter sequence "public"."rental_availability_id_seq" owned by "public"."rental_availability"."id";

alter sequence "public"."transaction_statuses_id_seq" owned by "public"."transaction_statuses"."id";

alter sequence "public"."transactions_id_seq" owned by "public"."transactions"."id";

CREATE UNIQUE INDEX blocked_users_pkey ON public.blocked_users USING btree (blocker_id, blocked_id);

CREATE UNIQUE INDEX contacts_pkey ON public.contacts USING btree (id);

CREATE UNIQUE INDEX favorites_pkey ON public.favorites USING btree (user_id, listing_id);

CREATE UNIQUE INDEX listing_statuses_pkey ON public.listing_statuses USING btree (id);

CREATE UNIQUE INDEX password_reset_tokens_pkey ON public.password_reset_tokens USING btree (id);

CREATE UNIQUE INDEX product_categories_pkey ON public.product_categories USING btree (id);

CREATE UNIQUE INDEX product_conditions_id_key ON public.product_conditions USING btree (id);

CREATE UNIQUE INDEX product_conditions_pkey ON public.product_conditions USING btree (id);

CREATE UNIQUE INDEX product_images_pkey ON public.product_images USING btree (product_listing_id, image_path);

CREATE UNIQUE INDEX product_listings_pkey ON public.product_listings USING btree (id);

CREATE UNIQUE INDEX profiles_email_key ON public.profiles USING btree (email);

CREATE UNIQUE INDEX proposal_statuses_pkey ON public.proposal_statuses USING btree (id);

CREATE UNIQUE INDEX proposal_types_pkey ON public.listing_types USING btree (id);

CREATE UNIQUE INDEX proposals_pkey ON public.proposals USING btree (id);

CREATE UNIQUE INDEX rental_availability_pkey ON public.rental_availability USING btree (id);

CREATE UNIQUE INDEX transaction_statuses_pkey ON public.transaction_statuses USING btree (id);

CREATE UNIQUE INDEX transactions_pkey ON public.transactions USING btree (id);

CREATE UNIQUE INDEX users_pkey ON public.profiles USING btree (id);

CREATE UNIQUE INDEX users_username_key ON public.profiles USING btree (username);

alter table "public"."blocked_users" add constraint "blocked_users_pkey" PRIMARY KEY using index "blocked_users_pkey";

alter table "public"."contacts" add constraint "contacts_pkey" PRIMARY KEY using index "contacts_pkey";

alter table "public"."favorites" add constraint "favorites_pkey" PRIMARY KEY using index "favorites_pkey";

alter table "public"."listing_statuses" add constraint "listing_statuses_pkey" PRIMARY KEY using index "listing_statuses_pkey";

alter table "public"."listing_types" add constraint "proposal_types_pkey" PRIMARY KEY using index "proposal_types_pkey";

alter table "public"."password_reset_tokens" add constraint "password_reset_tokens_pkey" PRIMARY KEY using index "password_reset_tokens_pkey";

alter table "public"."product_categories" add constraint "product_categories_pkey" PRIMARY KEY using index "product_categories_pkey";

alter table "public"."product_conditions" add constraint "product_conditions_pkey" PRIMARY KEY using index "product_conditions_pkey";

alter table "public"."product_images" add constraint "product_images_pkey" PRIMARY KEY using index "product_images_pkey";

alter table "public"."product_listings" add constraint "product_listings_pkey" PRIMARY KEY using index "product_listings_pkey";

alter table "public"."profiles" add constraint "users_pkey" PRIMARY KEY using index "users_pkey";

alter table "public"."proposal_statuses" add constraint "proposal_statuses_pkey" PRIMARY KEY using index "proposal_statuses_pkey";

alter table "public"."proposals" add constraint "proposals_pkey" PRIMARY KEY using index "proposals_pkey";

alter table "public"."rental_availability" add constraint "rental_availability_pkey" PRIMARY KEY using index "rental_availability_pkey";

alter table "public"."transaction_statuses" add constraint "transaction_statuses_pkey" PRIMARY KEY using index "transaction_statuses_pkey";

alter table "public"."transactions" add constraint "transactions_pkey" PRIMARY KEY using index "transactions_pkey";

alter table "public"."blocked_users" add constraint "fk_blockeduser_blocked" FOREIGN KEY (blocked_id) REFERENCES profiles(id) not valid;

alter table "public"."blocked_users" validate constraint "fk_blockeduser_blocked";

alter table "public"."blocked_users" add constraint "fk_blockeduser_blocker" FOREIGN KEY (blocker_id) REFERENCES profiles(id) not valid;

alter table "public"."blocked_users" validate constraint "fk_blockeduser_blocker";

alter table "public"."contacts" add constraint "fk_contact_user" FOREIGN KEY (user_id) REFERENCES profiles(id) not valid;

alter table "public"."contacts" validate constraint "fk_contact_user";

alter table "public"."favorites" add constraint "fk_favorite_listing" FOREIGN KEY (listing_id) REFERENCES product_listings(id) not valid;

alter table "public"."favorites" validate constraint "fk_favorite_listing";

alter table "public"."favorites" add constraint "fk_favorite_user" FOREIGN KEY (user_id) REFERENCES profiles(id) not valid;

alter table "public"."favorites" validate constraint "fk_favorite_user";

alter table "public"."password_reset_tokens" add constraint "password_reset_tokens_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."password_reset_tokens" validate constraint "password_reset_tokens_user_id_fkey";

alter table "public"."product_conditions" add constraint "product_conditions_id_key" UNIQUE using index "product_conditions_id_key";

alter table "public"."product_images" add constraint "fk_productimage_listing" FOREIGN KEY (product_listing_id) REFERENCES product_listings(id) not valid;

alter table "public"."product_images" validate constraint "fk_productimage_listing";

alter table "public"."product_listings" add constraint "fk_productlisting_category" FOREIGN KEY (category_id) REFERENCES product_categories(id) not valid;

alter table "public"."product_listings" validate constraint "fk_productlisting_category";

alter table "public"."product_listings" add constraint "fk_productlisting_owner" FOREIGN KEY (owner_id) REFERENCES profiles(id) not valid;

alter table "public"."product_listings" validate constraint "fk_productlisting_owner";

alter table "public"."product_listings" add constraint "fk_productlisting_status" FOREIGN KEY (listing_status) REFERENCES listing_statuses(id) not valid;

alter table "public"."product_listings" validate constraint "fk_productlisting_status";

alter table "public"."profiles" add constraint "profiles_email_key" UNIQUE using index "profiles_email_key";

alter table "public"."profiles" add constraint "profiles_location_id_fkey" FOREIGN KEY (location_id) REFERENCES postgis.locations(id) not valid;

alter table "public"."profiles" validate constraint "profiles_location_id_fkey";

alter table "public"."profiles" add constraint "users_username_key" UNIQUE using index "users_username_key";

alter table "public"."proposals" add constraint "fk_proposal_listing" FOREIGN KEY (listing_id) REFERENCES product_listings(id) not valid;

alter table "public"."proposals" validate constraint "fk_proposal_listing";

alter table "public"."proposals" add constraint "fk_proposal_receiver" FOREIGN KEY (receiver_id) REFERENCES profiles(id) not valid;

alter table "public"."proposals" validate constraint "fk_proposal_receiver";

alter table "public"."proposals" add constraint "fk_proposal_sender" FOREIGN KEY (sender_id) REFERENCES profiles(id) not valid;

alter table "public"."proposals" validate constraint "fk_proposal_sender";

alter table "public"."proposals" add constraint "fk_proposal_status" FOREIGN KEY (proposal_status_id) REFERENCES proposal_statuses(id) not valid;

alter table "public"."proposals" validate constraint "fk_proposal_status";

alter table "public"."proposals" add constraint "fk_proposal_type" FOREIGN KEY (proposal_type_id) REFERENCES listing_types(id) not valid;

alter table "public"."proposals" validate constraint "fk_proposal_type";

alter table "public"."transactions" add constraint "fk_transaction_listing" FOREIGN KEY (listing_id) REFERENCES product_listings(id) not valid;

alter table "public"."transactions" validate constraint "fk_transaction_listing";

alter table "public"."transactions" add constraint "fk_transaction_proposal" FOREIGN KEY (proposal_id) REFERENCES proposals(id) not valid;

alter table "public"."transactions" validate constraint "fk_transaction_proposal";

alter table "public"."transactions" add constraint "fk_transaction_status" FOREIGN KEY (transaction_status) REFERENCES transaction_statuses(id) not valid;

alter table "public"."transactions" validate constraint "fk_transaction_status";

alter table "public"."transactions" add constraint "transactions_buyer_id_fkey" FOREIGN KEY (buyer_id) REFERENCES profiles(id) not valid;

alter table "public"."transactions" validate constraint "transactions_buyer_id_fkey";

alter table "public"."transactions" add constraint "transactions_seller_id_fkey" FOREIGN KEY (seller_id) REFERENCES profiles(id) not valid;

alter table "public"."transactions" validate constraint "transactions_seller_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.calculate_user_balance(_owner_id uuid)
 RETURNS numeric
 LANGUAGE plpgsql
AS $function$DECLARE
    total_balance NUMERIC := 0;
    rental_income NUMERIC := 0;
    rental_expense NUMERIC := 0;
    sale_income NUMERIC := 0;
    sale_expense NUMERIC := 0;
    rental_days INT;
BEGIN
    -- Calcular ganhos e despesas de vendas
    SELECT 
        COALESCE(SUM(sp.offered_price), 0) INTO sale_income
    FROM transactions t
    JOIN sale_proposals sp ON t.proposal_id = sp.id
    WHERE t.seller_id = _owner_id;
    
    SELECT 
        COALESCE(SUM(sp.offered_price), 0) INTO sale_expense
    FROM transactions t
    JOIN sale_proposals sp ON t.proposal_id = sp.id
    WHERE t.buyer_id = _owner_id;


    -- Calcular ganhos de aluguel
SELECT 
  COALESCE(SUM(rp.offered_rent_per_day * DATE_PART('day', rp.end_date - rp.start_date)), 0)
  INTO rental_income
FROM transactions t
JOIN rental_proposals rp ON t.proposal_id = rp.id
WHERE t.seller_id = _owner_id;

-- Calcular despesas de aluguel
SELECT 
  COALESCE(SUM(rp.offered_rent_per_day * DATE_PART('day', rp.end_date - rp.start_date)), 0)
  INTO rental_expense
FROM transactions t
JOIN rental_proposals rp ON t.proposal_id = rp.id
WHERE t.buyer_id = _owner_id;

    -- Calcular saldo final
    total_balance := (sale_income + rental_income) - (sale_expense + rental_expense);

    RETURN total_balance;
END;$function$
;

CREATE OR REPLACE FUNCTION public.create_listing(p_title text, p_description text, p_category character varying, p_listing_type character varying, p_user_id uuid, p_listing_status character varying DEFAULT 'active'::character varying, p_product_condition text DEFAULT NULL::text, p_price numeric DEFAULT NULL::numeric, p_is_negotiable boolean DEFAULT NULL::boolean, p_deposit_required boolean DEFAULT NULL::boolean, p_cost_per_day numeric DEFAULT NULL::numeric, p_auto_close_date timestamp without time zone DEFAULT NULL::timestamp without time zone, p_rental_duration_limit integer DEFAULT NULL::integer, p_late_fee numeric DEFAULT NULL::numeric, p_desired_item text DEFAULT NULL::text, p_recipient_requirements text DEFAULT NULL::text)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_category_id INT;
  v_listing_status_id INT;
  v_listing_id INT;
  v_product_condition_id INT;
BEGIN
  -- Obter ID da categoria
  SELECT id INTO v_category_id FROM product_categories WHERE category = p_category;
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Categoria inválida: %', p_category;
  END IF;

  -- Obter ID do status
  SELECT id INTO v_listing_status_id FROM listing_statuses WHERE description = p_listing_status;
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Status inválido: %', p_listing_status;
  END IF;

  -- Obter ID do product_condition (se fornecido)
  IF p_product_condition IS NOT NULL THEN
    SELECT id INTO v_product_condition_id FROM product_conditions WHERE condition = p_product_condition;
    IF NOT FOUND THEN
      RAISE EXCEPTION 'Condição de produto inválida: %', p_product_condition;
    END IF;
  END IF;

  -- Inserir em product_listings
  INSERT INTO product_listings (title, description, owner_id, category_id, listing_status, date_created)
  VALUES (p_title, p_description, p_user_id, v_category_id, v_listing_status_id, NOW())
  RETURNING id INTO v_listing_id;

  -- Inserir conforme o tipo
  IF p_listing_type = 'sale' THEN
    INSERT INTO sale_listings (
      id, title, description, owner_id, category_id, listing_status,
      price, product_condition, is_negotiable
    )
    VALUES (
      v_listing_id, p_title, p_description, p_user_id, v_category_id,
      v_listing_status_id, p_price, v_product_condition_id, p_is_negotiable
    );

  ELSIF p_listing_type = 'rental' THEN
    INSERT INTO rental_listings (
      id, title, description, owner_id, category_id, listing_status,
      deposit_required, cost_per_day, auto_close_date, rental_duration_limit, late_fee
    )
    VALUES (
      v_listing_id, p_title, p_description, p_user_id, v_category_id, v_listing_status_id,
      p_deposit_required, p_cost_per_day, p_auto_close_date, p_rental_duration_limit, p_late_fee
    );

  ELSIF p_listing_type = 'swap' THEN
    INSERT INTO swap_listings (
      id, title, description, owner_id, category_id, listing_status, desired_item
    )
    VALUES (
      v_listing_id, p_title, p_description, p_user_id, v_category_id, v_listing_status_id, p_desired_item
    );

  ELSIF p_listing_type = 'giveaway' THEN
    INSERT INTO giveaway_listings (
      id, title, description, owner_id, category_id, listing_status, recipient_requirements
    )
    VALUES (
      v_listing_id, p_title, p_description, p_user_id, v_category_id, v_listing_status_id, p_recipient_requirements
    );

  ELSE
    RAISE EXCEPTION 'Tipo de anúncio inválido: %', p_listing_type;
  END IF;

  RETURN v_listing_id;

EXCEPTION
  WHEN OTHERS THEN
    RAISE EXCEPTION 'Erro ao criar anúncio: %', SQLERRM;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_location_and_update_profile(p_user_id text, p_address text, p_latitude double precision, p_longitude double precision)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public', 'gis', 'postgis'
AS $function$
DECLARE
    new_location_id INT;
    user_id UUID;
BEGIN
    -- Convert the string user_id to UUID
    user_id := p_user_id::UUID;

    -- Insert or update the location using gis.st_point()
    INSERT INTO postgis.locations (full_address, location, lat, lon)
    VALUES (
        p_address,
        postgis.st_point(p_longitude, p_latitude),
        p_longitude,
        p_latitude
    )
    ON CONFLICT (location) DO UPDATE
      SET full_address = EXCLUDED.full_address
    RETURNING id INTO new_location_id;

    -- Update the profile to reference the new location_id
    UPDATE profiles
    SET location_id = new_location_id
    WHERE id = user_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.create_proposal(_title text, _description text, _listing_id integer, _proposal_type text, _proposal_status text, _sender_id uuid DEFAULT NULL::uuid, _receiver_id uuid DEFAULT NULL::uuid, _offered_rent_per_day numeric DEFAULT NULL::numeric, _start_date timestamp without time zone DEFAULT NULL::timestamp without time zone, _end_date timestamp without time zone DEFAULT NULL::timestamp without time zone, _offered_price numeric DEFAULT NULL::numeric, _swap_with text DEFAULT NULL::text, _message text DEFAULT NULL::text)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
declare
  _proposal_type_id int;
  _proposal_status_id int;
  _new_proposal_id int;
  _result json;
begin
  -- Buscar IDs de tipo e status
  select listing_types.id into _proposal_type_id
  from listing_types
  where listing_types.description = _proposal_type;

  select proposal_statuses.id into _proposal_status_id
  from proposal_statuses
  where proposal_statuses.description = _proposal_status;

  -- Inserir na tabela base proposals
  insert into proposals (
    title, description, listing_id,
    proposal_type_id, proposal_status_id,
    sender_id, receiver_id, created_at
  ) values (
    _title, _description, _listing_id,
    _proposal_type_id, _proposal_status_id,
    _sender_id, _receiver_id, now()
  )
  returning proposals.id into _new_proposal_id;

  -- Inserir na tabela de herança apropriada
  if _proposal_type = 'sale' then
    insert into sale_proposals (
      id, title, description, listing_id,
      proposal_type_id, proposal_status_id,
      sender_id, receiver_id,
      offered_price, created_at
    )
    values (
      _new_proposal_id, _title, _description, _listing_id,
      _proposal_type_id, _proposal_status_id,
      _sender_id, _receiver_id,
      _offered_price, now()
    );

  elsif _proposal_type = 'rental' then
    insert into rental_proposals (
      id, title, description, listing_id,
      proposal_type_id, proposal_status_id,
      sender_id, receiver_id,
      offered_rent_per_day, start_date, end_date, created_at
    )
    values (
      _new_proposal_id, _title, _description, _listing_id,
      _proposal_type_id, _proposal_status_id,
      _sender_id, _receiver_id,
      _offered_rent_per_day, _start_date, _end_date, now()
    );

  elsif _proposal_type = 'swap' then
    insert into swap_proposals (
      id, title, description, listing_id,
      proposal_type_id, proposal_status_id,
      sender_id, receiver_id,
      swap_with, created_at
    )
    values (
      _new_proposal_id, _title, _description, _listing_id,
      _proposal_type_id, _proposal_status_id,
      _sender_id, _receiver_id,
      _swap_with, now()
    );

  elsif _proposal_type = 'giveaway' then
    insert into giveaway_proposals (
      id, title, description, listing_id,
      proposal_type_id, proposal_status_id,
      sender_id, receiver_id,
      message, created_at
    )
    values (
      _new_proposal_id, _title, _description, _listing_id,
      _proposal_type_id, _proposal_status_id,
      _sender_id, _receiver_id,
      _message, now()
    );

  end if;
 select json_build_object(
    'id', p.id,
    'title', p.title,
    'description', p.description
  )
  into _result
  from full_proposals p
  where p.id = _new_proposal_id;

  return _result;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.create_user(p_user_id uuid, p_user_name text, p_email text, p_name text, p_location_id integer DEFAULT NULL::integer, p_is_deleted boolean DEFAULT false, p_deleted_at timestamp without time zone DEFAULT NULL::timestamp without time zone)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
    INSERT INTO users (id, username, email, name, location_id, is_deleted, deleted_at)
    VALUES (p_user_id, p_user_name, p_email, p_name, p_location_id, p_is_deleted, p_deleted_at);
END;
$function$
;

CREATE OR REPLACE FUNCTION public.delete_used_reset_tokens()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  delete from password_reset_tokens
  where used = true
  and created_at < now() - interval '24 hours';
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.fetch_basic_proposals_of_user_by_status(p_user_id uuid, p_status text, p_limit integer, p_page integer)
 RETURNS TABLE(proposal_id integer, title text, description text, sender_id uuid, receiver_id uuid, receiver_name text, sender_name text, listing_id integer, listing_title text, proposal_type text, proposal_status text, created_at timestamp without time zone)
 LANGUAGE plpgsql
AS $function$BEGIN
    RETURN QUERY
    SELECT
        fp.id::integer AS proposal_id,
        fp.title::text AS title,
        fp.description::text AS description,
        fp.sender_id::uuid AS sender_id,
        fp.receiver_id::uuid AS receiver_id,
        fp.sender_name::text AS sender_name,
        fp.receiver_name::text AS receiver_name,
        fp.listing_id::integer AS listing_id,
        fp.listing_title::text AS listing_title,        
        fp.proposal_type::text AS proposal_type,
        fp.proposal_status::text AS proposal_status,
        fp.created_at::timestamp AS created_at
    FROM full_proposals fp
    WHERE (fp.sender_id = p_user_id OR fp.receiver_id = p_user_id)
    AND fp.proposal_status = p_status
    ORDER BY fp.created_at DESC
    OFFSET GREATEST((p_page - 1) * p_limit, 0)
    LIMIT p_limit;
END;$function$
;

CREATE OR REPLACE FUNCTION public.fetch_favorite(p_user_id uuid)
 RETURNS TABLE(id integer, title text)
 LANGUAGE plpgsql
AS $function$BEGIN
    RETURN QUERY
    SELECT
        pl.id As id,
        pl.title As title
    FROM
        favorites f
    JOIN
        full_product_listings pl ON f.listing_id = pl.id
    WHERE
        f.user_id = p_user_id;
END;$function$
;

CREATE OR REPLACE FUNCTION public.fetch_filtered_basic_proposals_by_user(p_user_id uuid, p_limit integer, p_page integer, p_received boolean DEFAULT false, p_sent boolean DEFAULT false, p_accepted boolean DEFAULT false, p_rejected boolean DEFAULT false, p_canceled boolean DEFAULT false)
 RETURNS TABLE(proposal_id integer, title text, description text, sender_id uuid, receiver_id uuid, sender_name text, receiver_name text, listing_id integer, listing_title text, proposal_type text, proposal_status text, created_at timestamp without time zone, total_count bigint)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    WITH filtered_proposals AS (
        SELECT DISTINCT ON (fp.id)
            fp.id::integer AS proposal_id,
            fp.title::text,
            fp.description::text,
            fp.sender_id::uuid,
            fp.receiver_id::uuid,
            fp.sender_name::text,
            fp.receiver_name::text,
            fp.listing_id::integer,
            fp.listing_title::text,
            fp.proposal_type::text,
            fp.proposal_status::text AS proposal_status,
            fp.created_at::timestamp
        FROM full_proposals fp
        WHERE
            (
                (p_received AND fp.receiver_id = p_user_id) OR
                (p_sent AND fp.sender_id = p_user_id) OR
                (NOT p_received AND NOT p_sent)  -- Allow proposals regardless of sender/receiver if neither filter is active
            )
            AND (
                (p_accepted AND fp.proposal_status = 'accepted') OR
                (p_rejected AND fp.proposal_status = 'rejected') OR
                (p_canceled AND fp.proposal_status = 'cancelled') OR
                (NOT p_accepted AND NOT p_rejected AND NOT p_canceled)  -- Allow all proposals if no status filter is active
            )
    ),
    total_count AS (
        SELECT COUNT(*) 
        FROM full_proposals fp
        WHERE
            (
                (p_received AND fp.receiver_id = p_user_id) OR
                (p_sent AND fp.sender_id = p_user_id) OR
                (NOT p_received AND NOT p_sent)  -- Allow proposals regardless of sender/receiver if neither filter is active
            )
            AND (
                (p_accepted AND fp.proposal_status = 'accepted') OR
                (p_rejected AND fp.proposal_status = 'rejected') OR
                (p_canceled AND fp.proposal_status = 'cancelled') OR
                (NOT p_accepted AND NOT p_rejected AND NOT p_canceled)  -- Allow all proposals if no status filter is active
            )
    )
    SELECT fp.*, (SELECT COUNT(*) FROM total_count) AS total_count
    FROM filtered_proposals fp
    ORDER BY created_at DESC
    OFFSET GREATEST((p_page - 1) * p_limit, 0)
    LIMIT p_limit;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.fetch_home_listings(_limit integer, _offset integer, _listing_type text DEFAULT NULL::text, _search text DEFAULT NULL::text)
 RETURNS TABLE(id text, title text, type text, price text, priceperday text, imageurl text, total_pages integer)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
    WITH total AS (
      SELECT COUNT(*) AS cnt
      FROM full_product_listings AS f
      WHERE 
        (_listing_type IS NULL OR f.listing_type = _listing_type)
        AND (_search IS NULL OR f.title ILIKE '%' || _search || '%')
    )
    SELECT 
      f.id::text,
      f.title,
      f.listing_type AS type,
      f.price::text,
      f.cost_per_day::text,
      '' AS imageUrl,
      -- Using CEIL on the total count divided by _limit to compute the number of pages.
      CEIL(total.cnt::numeric / NULLIF(_limit, 0))::integer AS total_pages
    FROM full_product_listings AS f, total
    WHERE 
      (_listing_type IS NULL OR f.listing_type = _listing_type)
      AND (_search IS NULL OR f.title ILIKE '%' || _search || '%')
    ORDER BY f.id
    LIMIT _limit OFFSET _offset;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.fetch_home_listings(_limit integer, _offset integer, _listing_type text DEFAULT NULL::text, _search text DEFAULT NULL::text, _lat double precision DEFAULT NULL::double precision, _lon double precision DEFAULT NULL::double precision, _dist double precision DEFAULT NULL::double precision)
 RETURNS TABLE(id text, title text, type text, price text, priceperday text, imageurl text, total_pages integer)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
    WITH total AS (
      SELECT COUNT(*) AS cnt
      FROM full_product_listings AS f
      JOIN profiles AS p ON f.owner_id = p.id
      LEFT JOIN postgis.locations AS l ON p.location_id = l.id
      WHERE 
        (_listing_type IS NULL OR f.listing_type = _listing_type)
        AND (_search IS NULL OR f.title ILIKE '%' || _search || '%')
        -- Only filter by location if all geolocation parameters are provided
        AND (
          _lat IS NULL OR _lon IS NULL OR _dist IS NULL OR
          (l.location IS NOT NULL AND
           postgis.st_dwithin(
              l.location,
              postgis.st_setsrid(postgis.st_point(_lon, _lat), 4326)::postgis.geography,
              _dist
           )
          )
        )
    )
    SELECT 
      f.id::text,
      f.title,
      f.listing_type AS type,
      f.price::text,
      f.cost_per_day::text,
      '' AS imageUrl,
      CEIL(total.cnt::numeric / NULLIF(_limit, 0))::integer AS total_pages
    FROM full_product_listings AS f
    JOIN profiles AS p ON f.owner_id = p.id
    LEFT JOIN postgis.locations AS l ON p.location_id = l.id
    CROSS JOIN total
    WHERE 
      (_listing_type IS NULL OR f.listing_type = _listing_type)
      AND (_search IS NULL OR f.title ILIKE '%' || _search || '%')
      AND (
          _lat IS NULL OR _lon IS NULL OR _dist IS NULL OR
          (l.location IS NOT NULL AND
           postgis.st_dwithin(
              l.location,
              postgis.st_setsrid(postgis.st_point(_lon, _lat), 4326)::postgis.geography,
              _dist
           )
          )
      )
    ORDER BY f.id
    LIMIT _limit OFFSET _offset;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.fetch_listings(_owner_id text, _limit integer, _offset integer)
 RETURNS TABLE(id text, title text, type text, price text, priceperday text, imageurl text)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
    SELECT
      p.id::text,
      p.title,
      CASE 
        WHEN s.id IS NOT NULL THEN 'sale'
        WHEN r.id IS NOT NULL THEN 'rental'
        WHEN g.id IS NOT NULL THEN 'giveaway'
        WHEN sw.id IS NOT NULL THEN 'swap'
        ELSE 'unknown'
      END AS type,
      s.price::text,
      r.cost_per_day::text,
      '' AS imageUrl
    FROM product_listings p
    LEFT JOIN sale_listings s ON s.id = p.id
    LEFT JOIN rental_listings r ON r.id = p.id
    LEFT JOIN giveaway_listings g ON g.id = p.id
    LEFT JOIN swap_listings sw ON sw.id = p.id
    WHERE p.owner_id = _owner_id::uuid
    ORDER BY p.id
    LIMIT _limit OFFSET _offset;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.fetch_proposal_by_id(p_proposal_id integer)
 RETURNS TABLE(proposal_id integer, title text, description text, sender_id uuid, sender_name text, receiver_id uuid, receiver_name text, listing_id integer, listing_title text, proposal_type_id integer, proposal_type text, proposal_status_id integer, status text, created_at timestamp without time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN
  RETURN QUERY
  SELECT
    f.id AS proposal_id,
    f.title::TEXT,
    f.description::TEXT,
    f.sender_id,
    sender.name::TEXT AS sender_name,
    f.receiver_id,
    receiver.name::TEXT AS receiver_name,
    f.listing_id,
    pl.title::TEXT AS listing_title,
    f.proposal_type_id,
    lt.description::TEXT AS proposal_type,
    f.proposal_status_id,
    ps.description::TEXT AS status,
    f.created_at
  FROM full_proposals f
  LEFT JOIN profiles sender ON f.sender_id = sender.id
  LEFT JOIN profiles receiver ON f.receiver_id = receiver.id
  LEFT JOIN product_listings pl ON f.listing_id = pl.id
  LEFT JOIN listing_types lt ON f.proposal_type_id = lt.id
  LEFT JOIN proposal_statuses ps ON f.proposal_status_id = ps.id
  WHERE f.id = p_proposal_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.fetch_received_basic_proposals_by_user(p_user_id uuid, p_limit integer, p_page integer)
 RETURNS TABLE(proposal_id integer, title text, description text, sender_id uuid, receiver_id uuid, sender_name text, listing_id integer, listing_title text, proposal_type text, proposal_status text, created_at timestamp without time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        fp.id::integer,
        fp.title::text,
        fp.description::text,
        fp.sender_id::uuid,
        fp.receiver_id::uuid,
        fp.sender_name::text,
        fp.listing_id::integer,
        fp.listing_title::text,
        fp.proposal_type::text,
        fp.proposal_status::text AS proposal_status,  -- Updated alias
        fp.created_at::timestamp
    FROM full_proposals fp
    WHERE fp.receiver_id = p_user_id
    ORDER BY fp.created_at DESC
    OFFSET GREATEST((p_page - 1) * p_limit, 0)
    LIMIT p_limit;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.fetch_sent_basic_proposals_by_user(p_user_id uuid, p_limit integer, p_page integer)
 RETURNS TABLE(proposal_id integer, title text, description text, sender_id uuid, receiver_id uuid, receiver_name text, listing_id integer, listing_title text, proposal_type text, proposal_status text, created_at timestamp without time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT
        fp.id::integer,
        fp.title::text,
        fp.description::text,
        fp.sender_id::uuid,
        fp.receiver_id::uuid,
        fp.sender_name::text,
        fp.listing_id::integer,
        fp.listing_title::text,
        fp.proposal_type::text,
        fp.proposal_status::text AS proposal_status,  -- Updated alias
        fp.created_at::timestamp
    FROM full_proposals fp
    WHERE fp.sender_id = p_user_id
    ORDER BY fp.created_at DESC
    OFFSET GREATEST((p_page - 1) * p_limit, 0)
    LIMIT p_limit;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.fetch_user_location(_user_id uuid)
 RETURNS TABLE(location_id integer, full_address text, lat double precision, lon double precision, created_at timestamp without time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  RETURN QUERY
  SELECT 
    l.id AS location_id,
    l.full_address,
    l.lat,
    l.lon,
    l.created_at
  FROM public.profiles AS p
  JOIN postgis.locations AS l ON p.location_id = l.id
  WHERE p.id = _user_id
    AND p.is_deleted IS NOT TRUE;
END;
$function$
;

create or replace view "public"."full_product_listings" as  SELECT p.id,
    p.title,
    p.description,
    p.date_created,
    p.owner_id,
    p.category_id,
    p.listing_status,
    'rental'::text AS listing_type,
    r.deposit_required,
    r.cost_per_day,
    r.auto_close_date,
    r.rental_duration_limit,
    r.late_fee,
    NULL::numeric AS price,
    NULL::integer AS product_condition,
    NULL::boolean AS is_negotiable,
    NULL::character varying AS desired_item,
    NULL::character varying AS recipient_requirements
   FROM (rental_listings r
     JOIN ONLY product_listings p ON ((p.id = r.id)))
UNION ALL
 SELECT p.id,
    p.title,
    p.description,
    p.date_created,
    p.owner_id,
    p.category_id,
    p.listing_status,
    'sale'::text AS listing_type,
    NULL::boolean AS deposit_required,
    NULL::numeric AS cost_per_day,
    NULL::timestamp without time zone AS auto_close_date,
    NULL::integer AS rental_duration_limit,
    NULL::numeric AS late_fee,
    s.price,
    s.product_condition,
    s.is_negotiable,
    NULL::character varying AS desired_item,
    NULL::character varying AS recipient_requirements
   FROM (sale_listings s
     JOIN ONLY product_listings p ON ((p.id = s.id)))
UNION ALL
 SELECT p.id,
    p.title,
    p.description,
    p.date_created,
    p.owner_id,
    p.category_id,
    p.listing_status,
    'swap'::text AS listing_type,
    NULL::boolean AS deposit_required,
    NULL::numeric AS cost_per_day,
    NULL::timestamp without time zone AS auto_close_date,
    NULL::integer AS rental_duration_limit,
    NULL::numeric AS late_fee,
    NULL::numeric AS price,
    NULL::integer AS product_condition,
    NULL::boolean AS is_negotiable,
    sw.desired_item,
    NULL::character varying AS recipient_requirements
   FROM (swap_listings sw
     JOIN ONLY product_listings p ON ((p.id = sw.id)))
UNION ALL
 SELECT p.id,
    p.title,
    p.description,
    p.date_created,
    p.owner_id,
    p.category_id,
    p.listing_status,
    'giveaway'::text AS listing_type,
    NULL::boolean AS deposit_required,
    NULL::numeric AS cost_per_day,
    NULL::timestamp without time zone AS auto_close_date,
    NULL::integer AS rental_duration_limit,
    NULL::numeric AS late_fee,
    NULL::numeric AS price,
    NULL::integer AS product_condition,
    NULL::boolean AS is_negotiable,
    NULL::character varying AS desired_item,
    g.recipient_requirements
   FROM (giveaway_listings g
     JOIN ONLY product_listings p ON ((p.id = g.id)));


create or replace view "public"."full_proposals" as  SELECT p.id,
    p.title,
    p.description,
    p.sender_id,
    p.receiver_id,
    p.listing_id,
    p.proposal_type_id,
    p.proposal_status_id,
    p.created_at,
    'sale'::text AS proposal_type,
    sp.offered_price,
    NULL::character varying AS swap_with,
    NULL::character varying AS message,
    NULL::numeric AS offered_rent_per_day,
    NULL::timestamp without time zone AS start_date,
    NULL::timestamp without time zone AS end_date,
    sender.name AS sender_name,
    receiver.name AS receiver_name,
    pl.title AS listing_title,
    ps.description AS proposal_status
   FROM (((((sale_proposals sp
     JOIN ONLY proposals p ON ((p.id = sp.id)))
     JOIN ONLY profiles sender ON ((sender.id = p.sender_id)))
     JOIN ONLY profiles receiver ON ((receiver.id = p.receiver_id)))
     JOIN ONLY product_listings pl ON ((pl.id = p.listing_id)))
     JOIN ONLY proposal_statuses ps ON ((ps.id = p.proposal_status_id)))
UNION ALL
 SELECT p.id,
    p.title,
    p.description,
    p.sender_id,
    p.receiver_id,
    p.listing_id,
    p.proposal_type_id,
    p.proposal_status_id,
    p.created_at,
    'swap'::text AS proposal_type,
    NULL::numeric AS offered_price,
    sw.swap_with,
    NULL::character varying AS message,
    NULL::numeric AS offered_rent_per_day,
    NULL::timestamp without time zone AS start_date,
    NULL::timestamp without time zone AS end_date,
    sender.name AS sender_name,
    receiver.name AS receiver_name,
    pl.title AS listing_title,
    ps.description AS proposal_status
   FROM (((((swap_proposals sw
     JOIN ONLY proposals p ON ((p.id = sw.id)))
     JOIN ONLY profiles sender ON ((sender.id = p.sender_id)))
     JOIN ONLY profiles receiver ON ((receiver.id = p.receiver_id)))
     JOIN ONLY product_listings pl ON ((pl.id = p.listing_id)))
     JOIN ONLY proposal_statuses ps ON ((ps.id = p.proposal_status_id)))
UNION ALL
 SELECT p.id,
    p.title,
    p.description,
    p.sender_id,
    p.receiver_id,
    p.listing_id,
    p.proposal_type_id,
    p.proposal_status_id,
    p.created_at,
    'giveaway'::text AS proposal_type,
    NULL::numeric AS offered_price,
    NULL::character varying AS swap_with,
    g.message,
    NULL::numeric AS offered_rent_per_day,
    NULL::timestamp without time zone AS start_date,
    NULL::timestamp without time zone AS end_date,
    sender.name AS sender_name,
    receiver.name AS receiver_name,
    pl.title AS listing_title,
    ps.description AS proposal_status
   FROM (((((giveaway_proposals g
     JOIN ONLY proposals p ON ((p.id = g.id)))
     JOIN ONLY profiles sender ON ((sender.id = p.sender_id)))
     JOIN ONLY profiles receiver ON ((receiver.id = p.receiver_id)))
     JOIN ONLY product_listings pl ON ((pl.id = p.listing_id)))
     JOIN ONLY proposal_statuses ps ON ((ps.id = p.proposal_status_id)))
UNION ALL
 SELECT p.id,
    p.title,
    p.description,
    p.sender_id,
    p.receiver_id,
    p.listing_id,
    p.proposal_type_id,
    p.proposal_status_id,
    p.created_at,
    'rental'::text AS proposal_type,
    NULL::numeric AS offered_price,
    NULL::character varying AS swap_with,
    NULL::character varying AS message,
    r.offered_rent_per_day,
    r.start_date,
    r.end_date,
    sender.name AS sender_name,
    receiver.name AS receiver_name,
    pl.title AS listing_title,
    ps.description AS proposal_status
   FROM (((((rental_proposals r
     JOIN ONLY proposals p ON ((p.id = r.id)))
     JOIN ONLY profiles sender ON ((sender.id = p.sender_id)))
     JOIN ONLY profiles receiver ON ((receiver.id = p.receiver_id)))
     JOIN ONLY product_listings pl ON ((pl.id = p.listing_id)))
     JOIN ONLY proposal_statuses ps ON ((ps.id = p.proposal_status_id)));


CREATE OR REPLACE FUNCTION public.get_basic_user_info(user_uuid uuid)
 RETURNS TABLE(id uuid, username text, name text, location_id integer, is_deleted boolean, deleted_at timestamp with time zone, created_at timestamp with time zone, last_signed_in timestamp with time zone)
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        p.id,
        p.username,
        p.name,
        p.location_id,
        p.is_deleted,
        p.deleted_at,
        u.created_at,
        u.last_sign_in_at
    FROM profiles p
    JOIN auth.users u ON p.id = u.id
    WHERE p.id = user_uuid;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_listing_json(listing_id integer)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
  result jsonb;
BEGIN
  SELECT jsonb_strip_nulls(jsonb_build_object(
      'id', id,
      'title', title,
      'description', description,
      'date_created', date_created,
      'owner_id', owner_id,
      'category_id', category_id,
      'listing_status', listing_status,
      'listing_type', listing_type,
      'deposit_required', deposit_required,
      'cost_per_day', cost_per_day,
      'auto_close_date', auto_close_date,
      'rental_duration_limit', rental_duration_limit,
      'late_fee', late_fee,
      'price', price,
      'product_condition', product_condition,
      'is_negotiable', is_negotiable,
      'desired_item', desired_item,
      'recipient_requirements', recipient_requirements
  ))
  INTO result
  FROM full_product_listings
  WHERE id = listing_id;
  
  RETURN result;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.get_proposal_json(proposal_id integer)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$DECLARE
  result jsonb;
BEGIN
  SELECT
    jsonb_strip_nulls(
      jsonb_build_object(
        'proposal_id', f.id,
        'title', f.title,
        'description', f.description,
        'created_at', f.created_at,
        'sender_id', f.sender_id,
        'receiver_id', f.receiver_id,
        'listing_id', f.listing_id,
        'listing_title', f.listing_title,
        'sender_name', f.sender_name,
        'receiver_name', f.receiver_name,
        'proposal_type', f.proposal_type,
        'proposal_status_id', f.proposal_status_id,
        'proposal_status', proposal_statuses.description,
        'offered_price', f.offered_price,
        'swap_with', f.swap_with,
        'message', f.message,
        'offered_rent_per_day', f.offered_rent_per_day,
        'start_date', f.start_date,
        'end_date', f.end_date
      )
    )
  INTO result
  FROM full_proposals f
  left join proposal_statuses on f.proposal_status_id=proposal_statuses.id
  WHERE f.id = proposal_id;

  RETURN result;
END;$function$
;

CREATE OR REPLACE FUNCTION public.get_user_profile(username text)
 RETURNS json
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$declare
    result json;
begin
    select json_build_object(
        'id', profiles.id,
        'name', profiles.name,
        'created_year', extract(year from auth_users.created_at),
        'active_listings', (
            select count(*)
            from product_listings
            where owner_id = profiles.id
            and listing_status = 1
        ),
        'total_sales', (
            select count(*)
            from transactions
            where seller_id = profiles.id
        ),
        'location', locations.full_address
    ) into result
    from profiles
    left join auth.users as auth_users on profiles.id = auth_users.id
    left join postgis.locations AS locations ON profiles.location_id = locations.id
    where profiles.username = get_user_profile.username;

    return result;
end;$function$
;

CREATE OR REPLACE FUNCTION public.get_user_proposals(p_user_id uuid, p_limit integer, p_offset integer)
 RETURNS TABLE(proposal_id integer, title text, description text, sender_id uuid, receiver_id uuid, listing_id integer, proposal_type text, proposal_status text, swap_with text, offered_price numeric, message text, offered_rent_per_day numeric, start_date timestamp without time zone, end_date timestamp without time zone, created_at timestamp without time zone, total_count bigint)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        p.id AS proposal_id,
        p.title::text,
        p.description::text,
        p.sender_id,
        p.receiver_id,
        p.listing_id,
        lt.description::text AS proposal_type,
        ps.description::text AS proposal_status,
        p.swap_with::text,
        p.offered_price,
        p.message::text,
        p.offered_rent_per_day,
        p.start_date,
        p.end_date,
        p.created_at,
        total.total_count
    FROM full_proposals p
    LEFT JOIN listing_types lt ON p.proposal_type_id = lt.id
    LEFT JOIN proposal_statuses ps ON p.proposal_status_id = ps.id
    CROSS JOIN (
        SELECT COUNT(*) AS total_count
        FROM full_proposals fp
        WHERE fp.sender_id = p_user_id OR fp.receiver_id = p_user_id
    ) total
    WHERE p.sender_id = p_user_id OR p.receiver_id = p_user_id
    ORDER BY p.id DESC
    LIMIT p_limit OFFSET p_offset;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  insert into profiles (id, username, name, email) 
  values (new.id, new.raw_user_meta_data->>'username', new.raw_user_meta_data->>'name', new.raw_user_meta_data->>'email');
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.insert_contact(_user_id text, _name text, _description text, _phone_number text)
 RETURNS TABLE(id integer, name text, phone_number text, description text)
 LANGUAGE plpgsql
AS $function$
begin
  -- Convert _user_id to UUID inside the function
  if (select count(*) from contacts where user_id = _user_id::uuid) >= 5 then
    raise exception 'Contact limit reached';
  end if;

  -- Insert the contact and return the values with the correct integer ID
  return query
  insert into contacts (user_id, name, description, phone_number)
  values (_user_id::uuid, _name, _description, _phone_number)
  returning contacts.id, contacts.name, contacts.phone_number, contacts.description;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.soft_delete_user(_user_id text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    user_uuid UUID;
BEGIN
    -- Convert text input to UUID
    user_uuid := _user_id::UUID;

    -- Delete user from auth table
    DELETE FROM auth.users WHERE id = user_uuid;

    -- Mark user as deleted in profiles
    UPDATE profiles
    SET is_deleted = TRUE, deleted_at = NOW()
    WHERE id = user_uuid;

    -- Remove user from blocked_users table (both as blocker and blocked)
    DELETE FROM blocked_users WHERE blocked_id = user_uuid OR blocker_id = user_uuid;

    -- Remove user from contacts table
    DELETE FROM contacts WHERE user_id = user_uuid;

    -- Remove user from favorites table
    DELETE FROM favorites WHERE user_id = user_uuid;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_auth_metadata(new_metadata jsonb, user_id text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$DECLARE user_uuid UUID;
new_email TEXT;
BEGIN
user_uuid:=user_id::UUID;
new_email := new_metadata->>'email';
  UPDATE auth.users
  SET raw_user_meta_data = COALESCE(raw_user_meta_data, '{}'::jsonb) || new_metadata
  WHERE id = user_uuid;

IF new_email IS NOT NULL AND new_email <> '' THEN
    UPDATE auth.users
    SET email = new_email
    WHERE id = user_uuid;
  END IF;
END;$function$
;

CREATE OR REPLACE FUNCTION public.update_proposal_status(p_proposal_id integer, p_new_status text, p_user_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$declare
  v_listing_id int;
  v_status_id int;
  v_receiver_id uuid;
  v_sender_id uuid;
begin
  -- Buscar o id do novo status
  select id into v_status_id
  from proposal_statuses
  where description = p_new_status;

  if not found then
    raise exception 'Status inválido: %', p_new_status;
  end if;

  -- Verificar se a proposta existe e buscar o receiver_id e sender_id
  select receiver_id, sender_id into v_receiver_id, v_sender_id
  from full_proposals
  where id = p_proposal_id;

  if v_receiver_id is null then
    raise exception 'Proposta não encontrada ou não tem receiver';
  end if;

  -- Lógica para verificar autorização com base no status
  if p_new_status = 'cancelled' then
    -- Apenas o sender pode cancelar a proposta
    if v_sender_id != p_user_id then
      raise exception 'Utilizador não autorizado a cancelar esta proposta';
    end if;
  else
    -- Para os outros status (aceitar ou rejeitar), apenas o receiver pode alterar
    if v_receiver_id != p_user_id then
      raise exception 'Utilizador não autorizado a alterar esta proposta';
    end if;

    -- Se accepted, buscar o listing_id da proposta e rejeitar as demais
    if p_new_status = 'accepted' then
      select listing_id into v_listing_id
      from proposals
      where id = p_proposal_id;

      update proposals
      set proposal_status_id = (
        select id from proposal_statuses where description = 'rejected'
      )
      where listing_id = v_listing_id
        and id != p_proposal_id;
    end if;
  end if;

  -- Atualizar o status da proposta
  update proposals
  set proposal_status_id = v_status_id
  where id = p_proposal_id;

  return true;
end;$function$
;

CREATE OR REPLACE FUNCTION public.update_user_data(user_id_text text, profile_data jsonb)
 RETURNS void
 LANGUAGE plpgsql
AS $function$DECLARE
  v_user_id UUID;
  v_email TEXT;
  v_username TEXT;
  v_name TEXT;
  v_location_id INT;
  v_user_metadata JSONB;
BEGIN
  -- Convert user_id from TEXT to UUID
  v_user_id := user_id_text::UUID;

  -- Extract fields from profile_data JSON
  v_email := profile_data->>'email';  
  v_username := profile_data->>'username';  
  v_name := profile_data->>'name';  
  v_location_id := (profile_data->>'location_id')::INT;

  -- Create metadata JSON object
  v_user_metadata := jsonb_build_object(
        'name', v_name,
        'username', v_username,
        'email', v_email,
        'location_id', v_location_id
    );

  -- CALL THE EXISTING FUNCTION TO UPDATE auth.users
  PERFORM update_auth_metadata(v_user_metadata, user_id_text);

  -- Update public.profiles
  UPDATE public.profiles
  SET 
    username = COALESCE(v_username, username),
    name = COALESCE(v_name, name),
    location_id = COALESCE(v_location_id, location_id),
    email=COALESCE(v_email, email)
  WHERE id = v_user_id;

END;$function$
;

grant delete on table "public"."blocked_users" to "anon";

grant insert on table "public"."blocked_users" to "anon";

grant references on table "public"."blocked_users" to "anon";

grant select on table "public"."blocked_users" to "anon";

grant trigger on table "public"."blocked_users" to "anon";

grant truncate on table "public"."blocked_users" to "anon";

grant update on table "public"."blocked_users" to "anon";

grant delete on table "public"."blocked_users" to "authenticated";

grant insert on table "public"."blocked_users" to "authenticated";

grant references on table "public"."blocked_users" to "authenticated";

grant select on table "public"."blocked_users" to "authenticated";

grant trigger on table "public"."blocked_users" to "authenticated";

grant truncate on table "public"."blocked_users" to "authenticated";

grant update on table "public"."blocked_users" to "authenticated";

grant delete on table "public"."blocked_users" to "service_role";

grant insert on table "public"."blocked_users" to "service_role";

grant references on table "public"."blocked_users" to "service_role";

grant select on table "public"."blocked_users" to "service_role";

grant trigger on table "public"."blocked_users" to "service_role";

grant truncate on table "public"."blocked_users" to "service_role";

grant update on table "public"."blocked_users" to "service_role";

grant delete on table "public"."contacts" to "anon";

grant insert on table "public"."contacts" to "anon";

grant references on table "public"."contacts" to "anon";

grant select on table "public"."contacts" to "anon";

grant trigger on table "public"."contacts" to "anon";

grant truncate on table "public"."contacts" to "anon";

grant update on table "public"."contacts" to "anon";

grant delete on table "public"."contacts" to "authenticated";

grant insert on table "public"."contacts" to "authenticated";

grant references on table "public"."contacts" to "authenticated";

grant select on table "public"."contacts" to "authenticated";

grant trigger on table "public"."contacts" to "authenticated";

grant truncate on table "public"."contacts" to "authenticated";

grant update on table "public"."contacts" to "authenticated";

grant delete on table "public"."contacts" to "service_role";

grant insert on table "public"."contacts" to "service_role";

grant references on table "public"."contacts" to "service_role";

grant select on table "public"."contacts" to "service_role";

grant trigger on table "public"."contacts" to "service_role";

grant truncate on table "public"."contacts" to "service_role";

grant update on table "public"."contacts" to "service_role";

grant delete on table "public"."favorites" to "anon";

grant insert on table "public"."favorites" to "anon";

grant references on table "public"."favorites" to "anon";

grant select on table "public"."favorites" to "anon";

grant trigger on table "public"."favorites" to "anon";

grant truncate on table "public"."favorites" to "anon";

grant update on table "public"."favorites" to "anon";

grant delete on table "public"."favorites" to "authenticated";

grant insert on table "public"."favorites" to "authenticated";

grant references on table "public"."favorites" to "authenticated";

grant select on table "public"."favorites" to "authenticated";

grant trigger on table "public"."favorites" to "authenticated";

grant truncate on table "public"."favorites" to "authenticated";

grant update on table "public"."favorites" to "authenticated";

grant delete on table "public"."favorites" to "service_role";

grant insert on table "public"."favorites" to "service_role";

grant references on table "public"."favorites" to "service_role";

grant select on table "public"."favorites" to "service_role";

grant trigger on table "public"."favorites" to "service_role";

grant truncate on table "public"."favorites" to "service_role";

grant update on table "public"."favorites" to "service_role";

grant delete on table "public"."giveaway_listings" to "anon";

grant insert on table "public"."giveaway_listings" to "anon";

grant references on table "public"."giveaway_listings" to "anon";

grant select on table "public"."giveaway_listings" to "anon";

grant trigger on table "public"."giveaway_listings" to "anon";

grant truncate on table "public"."giveaway_listings" to "anon";

grant update on table "public"."giveaway_listings" to "anon";

grant delete on table "public"."giveaway_listings" to "authenticated";

grant insert on table "public"."giveaway_listings" to "authenticated";

grant references on table "public"."giveaway_listings" to "authenticated";

grant select on table "public"."giveaway_listings" to "authenticated";

grant trigger on table "public"."giveaway_listings" to "authenticated";

grant truncate on table "public"."giveaway_listings" to "authenticated";

grant update on table "public"."giveaway_listings" to "authenticated";

grant delete on table "public"."giveaway_listings" to "service_role";

grant insert on table "public"."giveaway_listings" to "service_role";

grant references on table "public"."giveaway_listings" to "service_role";

grant select on table "public"."giveaway_listings" to "service_role";

grant trigger on table "public"."giveaway_listings" to "service_role";

grant truncate on table "public"."giveaway_listings" to "service_role";

grant update on table "public"."giveaway_listings" to "service_role";

grant delete on table "public"."giveaway_proposals" to "anon";

grant insert on table "public"."giveaway_proposals" to "anon";

grant references on table "public"."giveaway_proposals" to "anon";

grant select on table "public"."giveaway_proposals" to "anon";

grant trigger on table "public"."giveaway_proposals" to "anon";

grant truncate on table "public"."giveaway_proposals" to "anon";

grant update on table "public"."giveaway_proposals" to "anon";

grant delete on table "public"."giveaway_proposals" to "authenticated";

grant insert on table "public"."giveaway_proposals" to "authenticated";

grant references on table "public"."giveaway_proposals" to "authenticated";

grant select on table "public"."giveaway_proposals" to "authenticated";

grant trigger on table "public"."giveaway_proposals" to "authenticated";

grant truncate on table "public"."giveaway_proposals" to "authenticated";

grant update on table "public"."giveaway_proposals" to "authenticated";

grant delete on table "public"."giveaway_proposals" to "service_role";

grant insert on table "public"."giveaway_proposals" to "service_role";

grant references on table "public"."giveaway_proposals" to "service_role";

grant select on table "public"."giveaway_proposals" to "service_role";

grant trigger on table "public"."giveaway_proposals" to "service_role";

grant truncate on table "public"."giveaway_proposals" to "service_role";

grant update on table "public"."giveaway_proposals" to "service_role";

grant delete on table "public"."listing_statuses" to "anon";

grant insert on table "public"."listing_statuses" to "anon";

grant references on table "public"."listing_statuses" to "anon";

grant select on table "public"."listing_statuses" to "anon";

grant trigger on table "public"."listing_statuses" to "anon";

grant truncate on table "public"."listing_statuses" to "anon";

grant update on table "public"."listing_statuses" to "anon";

grant delete on table "public"."listing_statuses" to "authenticated";

grant insert on table "public"."listing_statuses" to "authenticated";

grant references on table "public"."listing_statuses" to "authenticated";

grant select on table "public"."listing_statuses" to "authenticated";

grant trigger on table "public"."listing_statuses" to "authenticated";

grant truncate on table "public"."listing_statuses" to "authenticated";

grant update on table "public"."listing_statuses" to "authenticated";

grant delete on table "public"."listing_statuses" to "service_role";

grant insert on table "public"."listing_statuses" to "service_role";

grant references on table "public"."listing_statuses" to "service_role";

grant select on table "public"."listing_statuses" to "service_role";

grant trigger on table "public"."listing_statuses" to "service_role";

grant truncate on table "public"."listing_statuses" to "service_role";

grant update on table "public"."listing_statuses" to "service_role";

grant delete on table "public"."listing_types" to "anon";

grant insert on table "public"."listing_types" to "anon";

grant references on table "public"."listing_types" to "anon";

grant select on table "public"."listing_types" to "anon";

grant trigger on table "public"."listing_types" to "anon";

grant truncate on table "public"."listing_types" to "anon";

grant update on table "public"."listing_types" to "anon";

grant delete on table "public"."listing_types" to "authenticated";

grant insert on table "public"."listing_types" to "authenticated";

grant references on table "public"."listing_types" to "authenticated";

grant select on table "public"."listing_types" to "authenticated";

grant trigger on table "public"."listing_types" to "authenticated";

grant truncate on table "public"."listing_types" to "authenticated";

grant update on table "public"."listing_types" to "authenticated";

grant delete on table "public"."listing_types" to "service_role";

grant insert on table "public"."listing_types" to "service_role";

grant references on table "public"."listing_types" to "service_role";

grant select on table "public"."listing_types" to "service_role";

grant trigger on table "public"."listing_types" to "service_role";

grant truncate on table "public"."listing_types" to "service_role";

grant update on table "public"."listing_types" to "service_role";

grant delete on table "public"."password_reset_tokens" to "anon";

grant insert on table "public"."password_reset_tokens" to "anon";

grant references on table "public"."password_reset_tokens" to "anon";

grant select on table "public"."password_reset_tokens" to "anon";

grant trigger on table "public"."password_reset_tokens" to "anon";

grant truncate on table "public"."password_reset_tokens" to "anon";

grant update on table "public"."password_reset_tokens" to "anon";

grant delete on table "public"."password_reset_tokens" to "authenticated";

grant insert on table "public"."password_reset_tokens" to "authenticated";

grant references on table "public"."password_reset_tokens" to "authenticated";

grant select on table "public"."password_reset_tokens" to "authenticated";

grant trigger on table "public"."password_reset_tokens" to "authenticated";

grant truncate on table "public"."password_reset_tokens" to "authenticated";

grant update on table "public"."password_reset_tokens" to "authenticated";

grant delete on table "public"."password_reset_tokens" to "service_role";

grant insert on table "public"."password_reset_tokens" to "service_role";

grant references on table "public"."password_reset_tokens" to "service_role";

grant select on table "public"."password_reset_tokens" to "service_role";

grant trigger on table "public"."password_reset_tokens" to "service_role";

grant truncate on table "public"."password_reset_tokens" to "service_role";

grant update on table "public"."password_reset_tokens" to "service_role";

grant delete on table "public"."product_categories" to "anon";

grant insert on table "public"."product_categories" to "anon";

grant references on table "public"."product_categories" to "anon";

grant select on table "public"."product_categories" to "anon";

grant trigger on table "public"."product_categories" to "anon";

grant truncate on table "public"."product_categories" to "anon";

grant update on table "public"."product_categories" to "anon";

grant delete on table "public"."product_categories" to "authenticated";

grant insert on table "public"."product_categories" to "authenticated";

grant references on table "public"."product_categories" to "authenticated";

grant select on table "public"."product_categories" to "authenticated";

grant trigger on table "public"."product_categories" to "authenticated";

grant truncate on table "public"."product_categories" to "authenticated";

grant update on table "public"."product_categories" to "authenticated";

grant delete on table "public"."product_categories" to "service_role";

grant insert on table "public"."product_categories" to "service_role";

grant references on table "public"."product_categories" to "service_role";

grant select on table "public"."product_categories" to "service_role";

grant trigger on table "public"."product_categories" to "service_role";

grant truncate on table "public"."product_categories" to "service_role";

grant update on table "public"."product_categories" to "service_role";

grant delete on table "public"."product_conditions" to "anon";

grant insert on table "public"."product_conditions" to "anon";

grant references on table "public"."product_conditions" to "anon";

grant select on table "public"."product_conditions" to "anon";

grant trigger on table "public"."product_conditions" to "anon";

grant truncate on table "public"."product_conditions" to "anon";

grant update on table "public"."product_conditions" to "anon";

grant delete on table "public"."product_conditions" to "authenticated";

grant insert on table "public"."product_conditions" to "authenticated";

grant references on table "public"."product_conditions" to "authenticated";

grant select on table "public"."product_conditions" to "authenticated";

grant trigger on table "public"."product_conditions" to "authenticated";

grant truncate on table "public"."product_conditions" to "authenticated";

grant update on table "public"."product_conditions" to "authenticated";

grant delete on table "public"."product_conditions" to "service_role";

grant insert on table "public"."product_conditions" to "service_role";

grant references on table "public"."product_conditions" to "service_role";

grant select on table "public"."product_conditions" to "service_role";

grant trigger on table "public"."product_conditions" to "service_role";

grant truncate on table "public"."product_conditions" to "service_role";

grant update on table "public"."product_conditions" to "service_role";

grant delete on table "public"."product_images" to "anon";

grant insert on table "public"."product_images" to "anon";

grant references on table "public"."product_images" to "anon";

grant select on table "public"."product_images" to "anon";

grant trigger on table "public"."product_images" to "anon";

grant truncate on table "public"."product_images" to "anon";

grant update on table "public"."product_images" to "anon";

grant delete on table "public"."product_images" to "authenticated";

grant insert on table "public"."product_images" to "authenticated";

grant references on table "public"."product_images" to "authenticated";

grant select on table "public"."product_images" to "authenticated";

grant trigger on table "public"."product_images" to "authenticated";

grant truncate on table "public"."product_images" to "authenticated";

grant update on table "public"."product_images" to "authenticated";

grant delete on table "public"."product_images" to "service_role";

grant insert on table "public"."product_images" to "service_role";

grant references on table "public"."product_images" to "service_role";

grant select on table "public"."product_images" to "service_role";

grant trigger on table "public"."product_images" to "service_role";

grant truncate on table "public"."product_images" to "service_role";

grant update on table "public"."product_images" to "service_role";

grant delete on table "public"."product_listings" to "anon";

grant insert on table "public"."product_listings" to "anon";

grant references on table "public"."product_listings" to "anon";

grant select on table "public"."product_listings" to "anon";

grant trigger on table "public"."product_listings" to "anon";

grant truncate on table "public"."product_listings" to "anon";

grant update on table "public"."product_listings" to "anon";

grant delete on table "public"."product_listings" to "authenticated";

grant insert on table "public"."product_listings" to "authenticated";

grant references on table "public"."product_listings" to "authenticated";

grant select on table "public"."product_listings" to "authenticated";

grant trigger on table "public"."product_listings" to "authenticated";

grant truncate on table "public"."product_listings" to "authenticated";

grant update on table "public"."product_listings" to "authenticated";

grant delete on table "public"."product_listings" to "service_role";

grant insert on table "public"."product_listings" to "service_role";

grant references on table "public"."product_listings" to "service_role";

grant select on table "public"."product_listings" to "service_role";

grant trigger on table "public"."product_listings" to "service_role";

grant truncate on table "public"."product_listings" to "service_role";

grant update on table "public"."product_listings" to "service_role";

grant delete on table "public"."profiles" to "anon";

grant insert on table "public"."profiles" to "anon";

grant references on table "public"."profiles" to "anon";

grant select on table "public"."profiles" to "anon";

grant trigger on table "public"."profiles" to "anon";

grant truncate on table "public"."profiles" to "anon";

grant update on table "public"."profiles" to "anon";

grant delete on table "public"."profiles" to "authenticated";

grant insert on table "public"."profiles" to "authenticated";

grant references on table "public"."profiles" to "authenticated";

grant select on table "public"."profiles" to "authenticated";

grant trigger on table "public"."profiles" to "authenticated";

grant truncate on table "public"."profiles" to "authenticated";

grant update on table "public"."profiles" to "authenticated";

grant delete on table "public"."profiles" to "service_role";

grant insert on table "public"."profiles" to "service_role";

grant references on table "public"."profiles" to "service_role";

grant select on table "public"."profiles" to "service_role";

grant trigger on table "public"."profiles" to "service_role";

grant truncate on table "public"."profiles" to "service_role";

grant update on table "public"."profiles" to "service_role";

grant delete on table "public"."proposal_statuses" to "anon";

grant insert on table "public"."proposal_statuses" to "anon";

grant references on table "public"."proposal_statuses" to "anon";

grant select on table "public"."proposal_statuses" to "anon";

grant trigger on table "public"."proposal_statuses" to "anon";

grant truncate on table "public"."proposal_statuses" to "anon";

grant update on table "public"."proposal_statuses" to "anon";

grant delete on table "public"."proposal_statuses" to "authenticated";

grant insert on table "public"."proposal_statuses" to "authenticated";

grant references on table "public"."proposal_statuses" to "authenticated";

grant select on table "public"."proposal_statuses" to "authenticated";

grant trigger on table "public"."proposal_statuses" to "authenticated";

grant truncate on table "public"."proposal_statuses" to "authenticated";

grant update on table "public"."proposal_statuses" to "authenticated";

grant delete on table "public"."proposal_statuses" to "service_role";

grant insert on table "public"."proposal_statuses" to "service_role";

grant references on table "public"."proposal_statuses" to "service_role";

grant select on table "public"."proposal_statuses" to "service_role";

grant trigger on table "public"."proposal_statuses" to "service_role";

grant truncate on table "public"."proposal_statuses" to "service_role";

grant update on table "public"."proposal_statuses" to "service_role";

grant delete on table "public"."proposals" to "anon";

grant insert on table "public"."proposals" to "anon";

grant references on table "public"."proposals" to "anon";

grant select on table "public"."proposals" to "anon";

grant trigger on table "public"."proposals" to "anon";

grant truncate on table "public"."proposals" to "anon";

grant update on table "public"."proposals" to "anon";

grant delete on table "public"."proposals" to "authenticated";

grant insert on table "public"."proposals" to "authenticated";

grant references on table "public"."proposals" to "authenticated";

grant select on table "public"."proposals" to "authenticated";

grant trigger on table "public"."proposals" to "authenticated";

grant truncate on table "public"."proposals" to "authenticated";

grant update on table "public"."proposals" to "authenticated";

grant delete on table "public"."proposals" to "service_role";

grant insert on table "public"."proposals" to "service_role";

grant references on table "public"."proposals" to "service_role";

grant select on table "public"."proposals" to "service_role";

grant trigger on table "public"."proposals" to "service_role";

grant truncate on table "public"."proposals" to "service_role";

grant update on table "public"."proposals" to "service_role";

grant delete on table "public"."rental_availability" to "anon";

grant insert on table "public"."rental_availability" to "anon";

grant references on table "public"."rental_availability" to "anon";

grant select on table "public"."rental_availability" to "anon";

grant trigger on table "public"."rental_availability" to "anon";

grant truncate on table "public"."rental_availability" to "anon";

grant update on table "public"."rental_availability" to "anon";

grant delete on table "public"."rental_availability" to "authenticated";

grant insert on table "public"."rental_availability" to "authenticated";

grant references on table "public"."rental_availability" to "authenticated";

grant select on table "public"."rental_availability" to "authenticated";

grant trigger on table "public"."rental_availability" to "authenticated";

grant truncate on table "public"."rental_availability" to "authenticated";

grant update on table "public"."rental_availability" to "authenticated";

grant delete on table "public"."rental_availability" to "service_role";

grant insert on table "public"."rental_availability" to "service_role";

grant references on table "public"."rental_availability" to "service_role";

grant select on table "public"."rental_availability" to "service_role";

grant trigger on table "public"."rental_availability" to "service_role";

grant truncate on table "public"."rental_availability" to "service_role";

grant update on table "public"."rental_availability" to "service_role";

grant delete on table "public"."rental_listings" to "anon";

grant insert on table "public"."rental_listings" to "anon";

grant references on table "public"."rental_listings" to "anon";

grant select on table "public"."rental_listings" to "anon";

grant trigger on table "public"."rental_listings" to "anon";

grant truncate on table "public"."rental_listings" to "anon";

grant update on table "public"."rental_listings" to "anon";

grant delete on table "public"."rental_listings" to "authenticated";

grant insert on table "public"."rental_listings" to "authenticated";

grant references on table "public"."rental_listings" to "authenticated";

grant select on table "public"."rental_listings" to "authenticated";

grant trigger on table "public"."rental_listings" to "authenticated";

grant truncate on table "public"."rental_listings" to "authenticated";

grant update on table "public"."rental_listings" to "authenticated";

grant delete on table "public"."rental_listings" to "service_role";

grant insert on table "public"."rental_listings" to "service_role";

grant references on table "public"."rental_listings" to "service_role";

grant select on table "public"."rental_listings" to "service_role";

grant trigger on table "public"."rental_listings" to "service_role";

grant truncate on table "public"."rental_listings" to "service_role";

grant update on table "public"."rental_listings" to "service_role";

grant delete on table "public"."rental_proposals" to "anon";

grant insert on table "public"."rental_proposals" to "anon";

grant references on table "public"."rental_proposals" to "anon";

grant select on table "public"."rental_proposals" to "anon";

grant trigger on table "public"."rental_proposals" to "anon";

grant truncate on table "public"."rental_proposals" to "anon";

grant update on table "public"."rental_proposals" to "anon";

grant delete on table "public"."rental_proposals" to "authenticated";

grant insert on table "public"."rental_proposals" to "authenticated";

grant references on table "public"."rental_proposals" to "authenticated";

grant select on table "public"."rental_proposals" to "authenticated";

grant trigger on table "public"."rental_proposals" to "authenticated";

grant truncate on table "public"."rental_proposals" to "authenticated";

grant update on table "public"."rental_proposals" to "authenticated";

grant delete on table "public"."rental_proposals" to "service_role";

grant insert on table "public"."rental_proposals" to "service_role";

grant references on table "public"."rental_proposals" to "service_role";

grant select on table "public"."rental_proposals" to "service_role";

grant trigger on table "public"."rental_proposals" to "service_role";

grant truncate on table "public"."rental_proposals" to "service_role";

grant update on table "public"."rental_proposals" to "service_role";

grant delete on table "public"."sale_listings" to "anon";

grant insert on table "public"."sale_listings" to "anon";

grant references on table "public"."sale_listings" to "anon";

grant select on table "public"."sale_listings" to "anon";

grant trigger on table "public"."sale_listings" to "anon";

grant truncate on table "public"."sale_listings" to "anon";

grant update on table "public"."sale_listings" to "anon";

grant delete on table "public"."sale_listings" to "authenticated";

grant insert on table "public"."sale_listings" to "authenticated";

grant references on table "public"."sale_listings" to "authenticated";

grant select on table "public"."sale_listings" to "authenticated";

grant trigger on table "public"."sale_listings" to "authenticated";

grant truncate on table "public"."sale_listings" to "authenticated";

grant update on table "public"."sale_listings" to "authenticated";

grant delete on table "public"."sale_listings" to "service_role";

grant insert on table "public"."sale_listings" to "service_role";

grant references on table "public"."sale_listings" to "service_role";

grant select on table "public"."sale_listings" to "service_role";

grant trigger on table "public"."sale_listings" to "service_role";

grant truncate on table "public"."sale_listings" to "service_role";

grant update on table "public"."sale_listings" to "service_role";

grant delete on table "public"."sale_proposals" to "anon";

grant insert on table "public"."sale_proposals" to "anon";

grant references on table "public"."sale_proposals" to "anon";

grant select on table "public"."sale_proposals" to "anon";

grant trigger on table "public"."sale_proposals" to "anon";

grant truncate on table "public"."sale_proposals" to "anon";

grant update on table "public"."sale_proposals" to "anon";

grant delete on table "public"."sale_proposals" to "authenticated";

grant insert on table "public"."sale_proposals" to "authenticated";

grant references on table "public"."sale_proposals" to "authenticated";

grant select on table "public"."sale_proposals" to "authenticated";

grant trigger on table "public"."sale_proposals" to "authenticated";

grant truncate on table "public"."sale_proposals" to "authenticated";

grant update on table "public"."sale_proposals" to "authenticated";

grant delete on table "public"."sale_proposals" to "service_role";

grant insert on table "public"."sale_proposals" to "service_role";

grant references on table "public"."sale_proposals" to "service_role";

grant select on table "public"."sale_proposals" to "service_role";

grant trigger on table "public"."sale_proposals" to "service_role";

grant truncate on table "public"."sale_proposals" to "service_role";

grant update on table "public"."sale_proposals" to "service_role";

grant delete on table "public"."swap_listings" to "anon";

grant insert on table "public"."swap_listings" to "anon";

grant references on table "public"."swap_listings" to "anon";

grant select on table "public"."swap_listings" to "anon";

grant trigger on table "public"."swap_listings" to "anon";

grant truncate on table "public"."swap_listings" to "anon";

grant update on table "public"."swap_listings" to "anon";

grant delete on table "public"."swap_listings" to "authenticated";

grant insert on table "public"."swap_listings" to "authenticated";

grant references on table "public"."swap_listings" to "authenticated";

grant select on table "public"."swap_listings" to "authenticated";

grant trigger on table "public"."swap_listings" to "authenticated";

grant truncate on table "public"."swap_listings" to "authenticated";

grant update on table "public"."swap_listings" to "authenticated";

grant delete on table "public"."swap_listings" to "service_role";

grant insert on table "public"."swap_listings" to "service_role";

grant references on table "public"."swap_listings" to "service_role";

grant select on table "public"."swap_listings" to "service_role";

grant trigger on table "public"."swap_listings" to "service_role";

grant truncate on table "public"."swap_listings" to "service_role";

grant update on table "public"."swap_listings" to "service_role";

grant delete on table "public"."swap_proposals" to "anon";

grant insert on table "public"."swap_proposals" to "anon";

grant references on table "public"."swap_proposals" to "anon";

grant select on table "public"."swap_proposals" to "anon";

grant trigger on table "public"."swap_proposals" to "anon";

grant truncate on table "public"."swap_proposals" to "anon";

grant update on table "public"."swap_proposals" to "anon";

grant delete on table "public"."swap_proposals" to "authenticated";

grant insert on table "public"."swap_proposals" to "authenticated";

grant references on table "public"."swap_proposals" to "authenticated";

grant select on table "public"."swap_proposals" to "authenticated";

grant trigger on table "public"."swap_proposals" to "authenticated";

grant truncate on table "public"."swap_proposals" to "authenticated";

grant update on table "public"."swap_proposals" to "authenticated";

grant delete on table "public"."swap_proposals" to "service_role";

grant insert on table "public"."swap_proposals" to "service_role";

grant references on table "public"."swap_proposals" to "service_role";

grant select on table "public"."swap_proposals" to "service_role";

grant trigger on table "public"."swap_proposals" to "service_role";

grant truncate on table "public"."swap_proposals" to "service_role";

grant update on table "public"."swap_proposals" to "service_role";

grant delete on table "public"."transaction_statuses" to "anon";

grant insert on table "public"."transaction_statuses" to "anon";

grant references on table "public"."transaction_statuses" to "anon";

grant select on table "public"."transaction_statuses" to "anon";

grant trigger on table "public"."transaction_statuses" to "anon";

grant truncate on table "public"."transaction_statuses" to "anon";

grant update on table "public"."transaction_statuses" to "anon";

grant delete on table "public"."transaction_statuses" to "authenticated";

grant insert on table "public"."transaction_statuses" to "authenticated";

grant references on table "public"."transaction_statuses" to "authenticated";

grant select on table "public"."transaction_statuses" to "authenticated";

grant trigger on table "public"."transaction_statuses" to "authenticated";

grant truncate on table "public"."transaction_statuses" to "authenticated";

grant update on table "public"."transaction_statuses" to "authenticated";

grant delete on table "public"."transaction_statuses" to "service_role";

grant insert on table "public"."transaction_statuses" to "service_role";

grant references on table "public"."transaction_statuses" to "service_role";

grant select on table "public"."transaction_statuses" to "service_role";

grant trigger on table "public"."transaction_statuses" to "service_role";

grant truncate on table "public"."transaction_statuses" to "service_role";

grant update on table "public"."transaction_statuses" to "service_role";

grant delete on table "public"."transactions" to "anon";

grant insert on table "public"."transactions" to "anon";

grant references on table "public"."transactions" to "anon";

grant select on table "public"."transactions" to "anon";

grant trigger on table "public"."transactions" to "anon";

grant truncate on table "public"."transactions" to "anon";

grant update on table "public"."transactions" to "anon";

grant delete on table "public"."transactions" to "authenticated";

grant insert on table "public"."transactions" to "authenticated";

grant references on table "public"."transactions" to "authenticated";

grant select on table "public"."transactions" to "authenticated";

grant trigger on table "public"."transactions" to "authenticated";

grant truncate on table "public"."transactions" to "authenticated";

grant update on table "public"."transactions" to "authenticated";

grant delete on table "public"."transactions" to "service_role";

grant insert on table "public"."transactions" to "service_role";

grant references on table "public"."transactions" to "service_role";

grant select on table "public"."transactions" to "service_role";

grant trigger on table "public"."transactions" to "service_role";

grant truncate on table "public"."transactions" to "service_role";

grant update on table "public"."transactions" to "service_role";

create policy "getContacts"
on "public"."contacts"
as permissive
for select
to public
using ((user_id = user_id));


create policy "Enable read access for all users"
on "public"."listing_statuses"
as permissive
for select
to public
using (true);


create policy "Enable read access for all users"
on "public"."product_categories"
as permissive
for select
to public
using (true);


create policy "Enable read access for all users"
on "public"."product_conditions"
as permissive
for select
to public
using (true);


create policy "Enable read access for all users"
on "public"."product_listings"
as permissive
for select
to public
using (true);


create policy "Enable authenticated user to update its profile data"
on "public"."profiles"
as permissive
for update
to public
using ((auth.uid() = id))
with check ((auth.uid() = id));


create policy "Enable insert for authenticated users only"
on "public"."profiles"
as permissive
for insert
to authenticated
with check (true);


create policy "Enable read access for all users"
on "public"."profiles"
as permissive
for select
to public
using (true);


CREATE TRIGGER cleanup_used_reset_tokens AFTER UPDATE ON public.password_reset_tokens FOR EACH ROW WHEN ((new.used = true)) EXECUTE FUNCTION delete_used_reset_tokens();


